#include "registry.h"
#include "util.h"
#include <windows.h>
#include <unordered_map>

static const std::unordered_map<std::string, HKEY> hkeyMap{
    { "HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT },
    { "HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG },
    { "HKEY_CURRENT_USER", HKEY_CURRENT_USER },
    { "HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE },
    { "HKEY_USERS", HKEY_USERS },
};

Napi::Value WithRegOpenWrap(const Napi::CallbackInfo &info) {
  try {
    if (info.Length() != 3) {
      throw Napi::Error::New(info.Env(), "Expected three parameters (hive, path, callback)");
    }

    std::string hiveV8(info[0].ToString());
    std::string pathV8(info[1].ToString());
    Napi::Function cb = info[2].As<Napi::Function>();

    auto iter = hkeyMap.find(hiveV8);
    if (iter == hkeyMap.end()) {
      throw Napi::Error::New(info.Env(), "Invalid hive specified");
    }
    std::wstring path = toWC(pathV8.c_str(), CodePage::UTF8, pathV8.length());

    HKEY key;
    LSTATUS res = ::RegOpenKeyExW(iter->second, path.c_str(), 0, KEY_READ, &key);
    if (res != ERROR_SUCCESS) {
      throw WinApiException(res, "WithRegOpen", pathV8.c_str());
    }

    auto buf = Napi::Buffer<uint8_t>::Copy(info.Env(), reinterpret_cast<uint8_t*>(&key), sizeof(HKEY));
    cb.Call({ buf });

    ::RegCloseKey(key);

    return info.Env().Undefined();
  }
  catch (const std::exception &e) {
    return Rethrow(info.Env(), e);
  }
}

const char *regTypeToString(DWORD type) {
  switch (type) {
    case REG_BINARY: return "REG_BINARY";
    case REG_DWORD: return "REG_DWORD";
    case REG_DWORD_BIG_ENDIAN: return "REG_DWORD_BIG_ENDIAN";
    case REG_EXPAND_SZ: return "REG_EXPAND_SZ";
    case REG_LINK: return "REG_LINK";
    case REG_MULTI_SZ: return "REG_MULTI_SZ";
    case REG_NONE: return "REG_NONE";
    case REG_QWORD: return "REG_QWORD";
    case REG_SZ: return "REG_SZ";
    default: throw std::runtime_error("invalid registry type");
  }
}

uint64_t toTimestamp(FILETIME ft)
{
  LARGE_INTEGER date;
  date.HighPart = ft.dwHighDateTime;
  date.LowPart = ft.dwLowDateTime;

  date.QuadPart -= (11644473600000 * 10000);

  return date.QuadPart / 10000;
}

HKEY decodeKeyParameter(Napi::Env &env, const Napi::Value &input) {
  HKEY key;
  if (input.IsString()) {
    std::string hkeyStr(input.ToString());
    auto iter = hkeyMap.find(hkeyStr.c_str());
    if (iter == hkeyMap.end()) {
      throw std::runtime_error("Invalid hive specified");
    }
    key = iter->second;
  }
  else if (input.IsBuffer()) {
    memcpy(&key, input.As<Napi::Buffer<uint8_t>>().Data(), sizeof(HKEY));
  } else {
    throw std::runtime_error("Parameter expected to be a buffer (as generated by WithRegOpen)");
  }

  return key;
}

Napi::Value RegSetKeyValueWrap(const Napi::CallbackInfo &info) {
  try {
    if (info.Length() != 4) {
      throw std::exception("Expected four parameters (key, subkey, name, data)");
    }

    HKEY key = decodeKeyParameter(info.Env(), info[0]);

    std::string pathV8(info[1].ToString());
    std::string nameV8(info[2].ToString());

    std::wstring path = toWC(pathV8.c_str(), CodePage::UTF8, pathV8.length());
    std::wstring name = toWC(nameV8.c_str(), CodePage::UTF8, nameV8.length());

    DWORD type;
    DWORD dataSize = 0;

    LSTATUS res = ::RegGetValueW(key, path.c_str(), name.c_str(), RRF_RT_ANY, &type, nullptr, &dataSize);

    if (res != ERROR_SUCCESS) {
      // have to assume the type based on the input value
      if (info[3].IsString()) {
        type = REG_SZ;
      }
      else if (info[3].IsNumber()) {
        type = REG_DWORD;
      }
      else if (info[3].IsBuffer()) {
        type = REG_BINARY;
      }
    }

    res = ERROR_INVALID_DATA;
    switch (type) {
      case REG_SZ: {
        std::wstring data = toWC(info[3]);
        res = ::RegSetKeyValueW(key, path.c_str(), name.c_str(), type, data.c_str(), wcslen(data.c_str()) * sizeof(wchar_t));
      } break;
      case REG_DWORD: {
        uint32_t data = info[3].ToNumber().Uint32Value();
        res = ::RegSetKeyValueW(key, path.c_str(), name.c_str(), type, &data, sizeof(DWORD));
      } break;
      case REG_BINARY: {
        Napi::Buffer<uint8_t> arr = info[3].As<Napi::Buffer<uint8_t>>();
        std::unique_ptr<uint8_t> buffer(new uint8_t[arr.Length()]);
        memcpy(buffer.get(), arr.Data(), arr.Length());
        res = ::RegSetKeyValueW(key, path.c_str(), name.c_str(), type, buffer.get(), arr.Length());
      } break;
    }

    if (res != ERROR_SUCCESS) {
      return ThrowWinApiException(info.Env(), res, "RegSetKeyValue", pathV8.c_str());
    }

    return info.Env().Undefined();
  }
  catch (const std::exception &e) {
    return Rethrow(info.Env(), e);
  }
}

Napi::Value RegGetValueWrap(const Napi::CallbackInfo &info) {
  try {
    if (info.Length() != 3) {
      throw std::exception("Expected three parameters (key, subkey, value)");
    }

    HKEY key = decodeKeyParameter(info.Env(), info[0]);

    std::string pathV8(info[1].ToString());
    std::string valueV8(info[2].ToString());

    std::wstring path = toWC(pathV8.c_str(), CodePage::UTF8, pathV8.length());
    std::wstring value = toWC(valueV8.c_str(), CodePage::UTF8, valueV8.length());

    DWORD type;
    DWORD dataSize = 0;

    LSTATUS res = ::RegGetValueW(key, path.c_str(), value.c_str(), RRF_RT_ANY, &type, nullptr, &dataSize);
    if (res != ERROR_SUCCESS) {
      throw WinApiException(res, "RegGetValue", pathV8.c_str());
    }

    std::shared_ptr<uint8_t[]> buffer(new uint8_t[dataSize]);

    res = ::RegGetValueW(key, path.c_str(), value.c_str(), RRF_RT_ANY, &type, buffer.get(), &dataSize);

    if (res != ERROR_SUCCESS) {
      throw WinApiException(res, "RegGetValue", pathV8.c_str());
    }

    Napi::Object result = Napi::Object::New(info.Env());
    result.Set("type", Napi::String::New(info.Env(), regTypeToString(type)));

    switch (type) {
      case REG_BINARY: {
        result.Set("value", Napi::Buffer<uint8_t>::Copy(info.Env(), reinterpret_cast<uint8_t*>(buffer.get()), dataSize));
      } break;
      case REG_DWORD: {
        DWORD val = *reinterpret_cast<DWORD*>(buffer.get());
        result.Set("value", Napi::Number::New(info.Env(), val));
      } break;
      case REG_DWORD_BIG_ENDIAN: {
        union {
          DWORD val;
          char temp[4];
        };
        for (int i = 0; i < 4; ++i) {
          temp[i] = buffer[3 - i];
        }
        result.Set("value", Napi::Number::New(info.Env(), val));
      } break;
      case REG_MULTI_SZ: {
        result.Set("value", convertMultiSZ(info.Env(), reinterpret_cast<wchar_t*>(buffer.get()), dataSize));
      } break;
      case REG_NONE: { } break;
      case REG_QWORD: {
        result.Set("value", Napi::Number::New(info.Env(), static_cast<double>(*reinterpret_cast<uint64_t*>(buffer.get()))));
      } break;
      case REG_SZ:
      case REG_EXPAND_SZ:
      case REG_LINK: {
        const wchar_t *buf = reinterpret_cast<wchar_t*>(buffer.get());
        result.Set("value", Napi::String::New(info.Env(), toMB(buf, CodePage::UTF8, (dataSize / sizeof(wchar_t)) - 1)));
      } break;
    }

    return result;
  }
  catch (const std::exception &e) {
    return Rethrow(info.Env(), e);
  }
}

Napi::Value RegEnumKeysWrap(const Napi::CallbackInfo &info) {
  try {
    if (info.Length() != 1) {
      throw std::exception("Expected one parameters (key)");
    }

    if (!info[0].IsBuffer()) {
      throw std::exception("Parameter expected to be a buffer (as generated by WithRegOpen)");
    }

    HKEY key;
    memcpy(&key, info[0].As<Napi::Buffer<uint8_t>>().Data(), sizeof(HKEY));

    DWORD numSubkeys;
    DWORD maxSubkeyLen;
    DWORD maxClassLen;
    LSTATUS res = RegQueryInfoKey(key, nullptr, nullptr, nullptr, &numSubkeys, &maxSubkeyLen, &maxClassLen, nullptr, nullptr, nullptr, nullptr, nullptr);
    if (res != ERROR_SUCCESS) {
      return ThrowWinApiException(info.Env(), res, "RegEnumKeys");
    }

    Napi::Array result = Napi::Array::New(info.Env());
    std::shared_ptr<wchar_t[]> keyBuffer(new wchar_t[maxSubkeyLen + 1]);
    std::shared_ptr<wchar_t[]> classBuffer(new wchar_t[maxClassLen + 1]);
    for (DWORD i = 0; i < numSubkeys; ++i) {
      DWORD keyLen = maxSubkeyLen + 1;
      DWORD classLen = maxClassLen + 1;
      FILETIME lastWritten;
      res = ::RegEnumKeyExW(key, i, keyBuffer.get(), &keyLen, nullptr, classBuffer.get(), &classLen, &lastWritten);
      if (res == ERROR_NO_MORE_ITEMS) {
        // https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regenumkeyexw#remarks
        // Registry must've been manipulated since we called RegQueryInfoKey
        //  and the total number of subKeys has been reduced. (user uninstalled something ?)
        // Either way, we don't want to lose any information we've already collected and
        //  there's no point in continuing past this point so we break out of the for loop.
        break;
      }
      else if (res != ERROR_SUCCESS) {
        return ThrowWinApiException(info.Env(), res, "RegEnumKeys");
      }

      Napi::Object item = Napi::Object::New(info.Env());
      item.Set("class", Napi::String::New(info.Env(), toMB(classBuffer.get(), CodePage::UTF8, classLen)));
      item.Set("key", Napi::String::New(info.Env(), toMB(keyBuffer.get(), CodePage::UTF8, keyLen)));
      item.Set("lastWritten", Napi::Number::New(info.Env(), static_cast<double>(toTimestamp(lastWritten))));
      result.Set(i, item);
    }

    return result;
  }
  catch (const std::exception &e) {
    return Rethrow(info.Env(), e);
  }
}

Napi::Value RegEnumValuesWrap(const Napi::CallbackInfo &info) {
  try {
    if (info.Length() != 1) {
      throw std::exception("Expected one parameters (key)");
    }

    if (!info[0].IsBuffer()) {
      throw std::exception("Parameter expected to be a buffer (as generated by WithRegOpen)");
    }

    HKEY key;
    memcpy(&key, info[0].As<Napi::Buffer<uint8_t>>().Data(), sizeof(HKEY));

    DWORD numValues;
    DWORD maxKeyLen;
    LSTATUS res = RegQueryInfoKey(key, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, &numValues, &maxKeyLen, nullptr, nullptr, nullptr);
    if (res != ERROR_SUCCESS) {
      throw WinApiException(res, "RegEnumValues");
    }

    Napi::Array result = Napi::Array::New(info.Env());
    std::shared_ptr<wchar_t[]> keyBuffer(new wchar_t[maxKeyLen + 1]);
    for (DWORD i = 0; i < numValues; ++i) {
      DWORD keyLen = maxKeyLen + 1;
      DWORD type;
      res = ::RegEnumValueW(key, i, keyBuffer.get(), &keyLen, nullptr, &type, nullptr, nullptr);
      if (res != ERROR_SUCCESS) {
        throw WinApiException(res, "RegEnumValues");
      }

      Napi::Object item = Napi::Object::New(info.Env());
      item.Set("type", Napi::String::New(info.Env(), regTypeToString(type)));
      item.Set("key", Napi::String::New(info.Env(), toMB(keyBuffer.get(), CodePage::UTF8, keyLen)));
      result.Set( i, item);
    }

    return result;
  }
  catch (const std::exception &e) {
    return Rethrow(info.Env(), e);
  }
}

namespace Registry {
  void Init(Napi::Env env, Napi::Object exports) {
    exports.Set("WithRegOpen", Napi::Function::New(env, WithRegOpenWrap));
    exports.Set("RegGetValue", Napi::Function::New(env, RegGetValueWrap));
    exports.Set("RegSetKeyValue", Napi::Function::New(env, RegSetKeyValueWrap));
    exports.Set("RegEnumKeys", Napi::Function::New(env, RegEnumKeysWrap));
    exports.Set("RegEnumValues", Napi::Function::New(env, RegEnumValuesWrap));
  }
}

